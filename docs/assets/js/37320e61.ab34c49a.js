"use strict";(self.webpackChunk_rjsf_docs=self.webpackChunk_rjsf_docs||[]).push([[5132],{1184:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>d});var o=i(4041);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},2151:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"usage/layout-grid","title":"Layout Grid","description":"Version 6 of RJSF introduced a new way of generating forms using the UiSchema, via the Layout Grid.","source":"@site/docs/usage/layout-grid.md","sourceDirName":"usage","slug":"/usage/layout-grid","permalink":"/react-jsonschema-form/docs/usage/layout-grid","draft":false,"unlisted":false,"editUrl":"https://github.com/rjsf-team/react-jsonschema-form/tree/main/packages/docs/docs/usage/layout-grid.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Usage and Customization","permalink":"/react-jsonschema-form/docs/usage/"},"next":{"title":"Themes","permalink":"/react-jsonschema-form/docs/usage/themes"}}');var t=i(1085),s=i(1184);const r={},d="Layout Grid",a={},l=[{value:"Defining the LayoutGridField to reordering rows",id:"defining-the-layoutgridfield-to-reordering-rows",level:2},{value:"ui",id:"ui",level:3},{value:"ui, part 1",id:"ui-part-1",level:3},{value:"LayoutHeaderField",id:"layoutheaderfield",level:2},{value:"Defining the LayoutGridField to put the fields in a single row",id:"defining-the-layoutgridfield-to-put-the-fields-in-a-single-row",level:2},{value:"ui, part 2",id:"ui-part-2",level:3},{value:"ui",id:"ui-1",level:3},{value:"ui",id:"ui-2",level:3},{value:"GridTemplate",id:"gridtemplate",level:2},{value:"Defining the LayoutGridField to render fields conditionally",id:"defining-the-layoutgridfield-to-render-fields-conditionally",level:2},{value:"ui",id:"ui-3",level:3},{value:"Other capabilities of the LayoutGridField",id:"other-capabilities-of-the-layoutgridfield",level:2},{value:"Named lookup support for className",id:"named-lookup-support-for-classname",level:3},{value:"Rendering a custom React element in the grid",id:"rendering-a-custom-react-element-in-the-grid",level:3},{value:"Passing components directly in uiSchema",id:"passing-components-directly-in-uischema",level:4},{value:"Other named lookup situations",id:"other-named-lookup-situations",level:3},{value:"So much flexibility available",id:"so-much-flexibility-available",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"layout-grid",children:"Layout Grid"})}),"\n",(0,t.jsxs)(n.p,{children:["Version 6 of RJSF introduced a new way of generating forms using the ",(0,t.jsx)(n.code,{children:"UiSchema"}),", via the Layout Grid.\nUnlike the original method of showing each field in the JSON Schema, in order, as they appear hierarchically within the\nnested object hierarchy, the Layout Grid lets you define where each field goes on a grid in any place/order you choose.\nIt even adds the ability to pass additional props to the rendering widget for each element being displayed."]}),"\n",(0,t.jsxs)(n.p,{children:["The Layout Grid takes full advantage of the ",(0,t.jsx)(n.code,{children:"UiSchema"}),"'s ability to customize the ",(0,t.jsx)(n.code,{children:"ui:field"})," that is used to render a field\nor collection of fields by providing a new out-of-the-box field implementation called ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," that you can\nassign to the whole of the ",(0,t.jsx)(n.code,{children:"schema"}),' or just a piece of it. It also comes with its own "syntax" that lets you define\na ',(0,t.jsx)(n.code,{children:"row"}),", a ",(0,t.jsx)(n.code,{children:"col"}),"umn, and a set of ",(0,t.jsx)(n.code,{children:"columns"}),". It also provides ",(0,t.jsx)(n.code,{children:"condition"}),"al logic that describes how a subset of the grid\ncan be hidden/shown based upon the value(s) of a field. It even supports the inclusion of custom render components that\nare not associated with a field. Finally, there is built-in support for doing a named look up of data within a special\nlocation in the ",(0,t.jsx)(n.code,{children:"FormContext"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Since each theme that RJSF supports has its own unique grid system, the ",(0,t.jsx)(n.code,{children:"uiSchema"})," that one creates for the\n",(0,t.jsx)(n.code,{children:"LayoutGridField"})," for one theme will most likely not work for any other theme unless two themes have the exact same\ngrid specification props. It also requires that one understand how to use the grid system of the theme and how it\ninterplays with the ",(0,t.jsx)(n.code,{children:"LayoutGridField"}),'\'s "syntax". In other words, it will likely take some experimentation to get the\ngrid looking exactly the way you want it to.']}),"\n",(0,t.jsxs)(n.p,{children:["Let's break down how to use the ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," one step at a time."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-layoutgridfield-to-reordering-rows",children:"Defining the LayoutGridField to reordering rows"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," is designed to be used within the ",(0,t.jsx)(n.code,{children:"uiSchema"})," via the ",(0,t.jsx)(n.code,{children:"ui:field"})," syntax. It must be accompanied by\nthe definition of the grid within the new ",(0,t.jsx)(n.code,{children:"ui:layoutGrid"})," syntax. First let's start with a fairly simple ",(0,t.jsx)(n.code,{children:"schema"})," that\nlooks like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "type": "object",\n  "properties": {\n    "person": {\n      "title": "Person Info",\n      "type": "object",\n      "properties": {\n        "first": {\n          "title": "First Name",\n          "minLength": 1,\n          "maxLength": 200,\n          "type": "string"\n        },\n        "middle": {\n          "title": "Middle Name",\n          "minLength": 1,\n          "maxLength": 200,\n          "type": "string"\n        },\n        "last": {\n          "title": "Last Name",\n          "minLength": 1,\n          "maxLength": 200,\n          "type": "string"\n        }\n      },\n      "required": ["first", "last"]\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you were to pass this ",(0,t.jsx)(n.code,{children:"schema"})," to the RJSF ",(0,t.jsx)(n.code,{children:"Form"})," you will end up with the following UI, shown here as a simple ASCII\ndrawing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Person Info\n  First Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  Middle Name\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  Last Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you wanted to switch the order of the fields or remove middle name entirely, you could change the JSON schema, which\nis usually not desirable for most users. You could also use the ",(0,t.jsx)(n.code,{children:"ui:order"})," feature and/or ",(0,t.jsx)(n.code,{children:'ui:widget: "hidden"'})," in the\n",(0,t.jsx)(n.code,{children:"uiSchema"})," to accomplish this without changing the schema. And now you can also use the very flexible and powerful\n",(0,t.jsx)(n.code,{children:"LayoutGridField"})," field in the",(0,t.jsx)(n.code,{children:"uiSchema"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Now let's add a ",(0,t.jsx)(n.code,{children:"uiSchema"})," that will allow us to change the order of the fields to be ",(0,t.jsx)(n.code,{children:"Last Name"}),", ",(0,t.jsx)(n.code,{children:"Middle Name"})," and ",(0,t.jsx)(n.code,{children:"First Name"}),'.\nThis will highlight the first elements of the new "syntax"; ',(0,t.jsx)(n.code,{children:"ui:layoutGrid"})," and ",(0,t.jsx)(n.code,{children:"ui:row"})," :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "children": ["person.last", "person.middle", "person.first"]\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This results in the following UI using the ",(0,t.jsx)(n.code,{children:"core"})," theme via the ",(0,t.jsx)(n.code,{children:"Bootstrap 3"})," grid system:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"  Last Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  Middle Name\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  First Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As mentioned before, another theme's grid system may render the above example differently. Most likely as three fields\nlined up next to each other. Assume all examples from here on out will be shown using the ",(0,t.jsx)(n.code,{children:"core"})," theme. You may have to\nadjust the ",(0,t.jsx)(n.code,{children:"uiSchema"})," for your theme to achieve the same results."]}),"\n",(0,t.jsxs)(n.h3,{id:"ui",children:["ui",":layoutGrid"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," will do nothing if used as a field without having the ",(0,t.jsx)(n.code,{children:"ui:layoutGrid"}),' object as its sibling.\nThis root "syntax" keyword defines the structure of how the grid should be laid out for the field. Due to the nature of\nJSON objects, it must contain a single ',(0,t.jsx)(n.code,{children:"ui:row"}),' "syntax" keyword inside of which the rest of the grid is defined. Providing\na second ',(0,t.jsx)(n.code,{children:"ui:row"})," will create an invalid object."]}),"\n",(0,t.jsxs)(n.h3,{id:"ui-part-1",children:["ui",":row",", part 1"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ui:row"}),' "syntax" represents a row of data in the grid. It has, at minimum, a single ',(0,t.jsx)(n.code,{children:"children"})," property that\ndescribes what that row will render. In this first example, the children are the ids of the fields to render in order,\nas single grid elements. There is a second version of this syntax which is identical to the first in behavior:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": ["person.last", "person.middle", "person.first"]\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here the array is implicitly assumed to be the ",(0,t.jsx)(n.code,{children:"children"})," property. Let's take a look at another example that will generate\nthe exact same UI. The example below shows what happens when you use the ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," on a sub-object within the\nhierarchy:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "person": {\n    "ui:field": "LayoutGridField",\n    "ui:layoutGrid": {\n      "ui:row": ["last", "middle", "first"]\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here you can see the ",(0,t.jsx)(n.code,{children:"person."})," prefix on the field ids is no longer necessary. This is because the scope of the field is\nnow the ",(0,t.jsx)(n.code,{children:"person"})," object rather than the whole of the ",(0,t.jsx)(n.code,{children:"schema"}),". You may have noticed from the example UI shown above that\nthe ",(0,t.jsx)(n.code,{children:"Person Info"})," header for the object disappeared. This is because we are no longer iterating through the hierarchy to\nrender the object. Don't worry, there is another new field that was created to support just this use case (see next\nsection)."]}),"\n",(0,t.jsxs)(n.p,{children:["Also, if you wanted to entirely remove the ",(0,t.jsx)(n.code,{children:"Middle Name"})," from your form because of a requirements change, you don't have\nto touch the JSON schema anymore. Instead you would just update the ",(0,t.jsx)(n.code,{children:"uiSchema"})," as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": ["person.last", "person.first"]\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"layoutheaderfield",children:"LayoutHeaderField"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"LayoutHeaderField"})," is another new field built into RJSF v6. Its sole purpose is to render the ",(0,t.jsx)(n.code,{children:"title"})," for a collection\nof grid elements. It will read the ",(0,t.jsx)(n.code,{children:"title"})," using the exact same mechanism as does the regular ",(0,t.jsx)(n.code,{children:"Form"}),"; first as ",(0,t.jsx)(n.code,{children:"ui:title"}),"\nif specified, then as ",(0,t.jsx)(n.code,{children:"schema.title"})," if specified, then as ",(0,t.jsx)(n.code,{children:"name"})," of the field. In order to restore the ",(0,t.jsx)(n.code,{children:"Person Info"}),"\nheader to the example above, we have to make a few additions to the ",(0,t.jsx)(n.code,{children:"uiSchema"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": ["person", "person.last", "person.middle", "person.first"]\n  },\n  "person": {\n    "ui:field": "LayoutHeaderField"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-layoutgridfield-to-put-the-fields-in-a-single-row",children:"Defining the LayoutGridField to put the fields in a single row"}),"\n",(0,t.jsxs)(n.p,{children:["Now let's say the requirements changed again, and you have to show the first, middle and last name fields in a single row.\nWell, in the past, that would require quite a lot of customizing of RJSF's ",(0,t.jsx)(n.code,{children:"core"})," templates. Now with the ",(0,t.jsx)(n.code,{children:"LayoutGridField"}),"\nit's just a matter of updating the ",(0,t.jsx)(n.code,{children:"uiSchema"}),' again, this time using more of the new "syntax"; ',(0,t.jsx)(n.code,{children:"ui:col"})," and ",(0,t.jsx)(n.code,{children:"ui:columns"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "row",\n      "children": [\n        {\n          "ui:row": [\n            {\n              "ui:col": {\n                "className": "col-xs-12",\n                "children": ["person"]\n              }\n            }\n          ]\n        },\n        {\n          "ui:row": [\n            {\n              "ui:col": {\n                "className": "col-xs-4",\n                "children": [\n                  {\n                    "name": "person.first"\n                  }\n                ]\n              }\n            },\n            {\n              "ui:col": {\n                "className": "col-xs-4",\n                "children": [\n                  {\n                    "name": "person.middle"\n                  }\n                ]\n              }\n            },\n            {\n              "ui:col": {\n                "className": "col-xs-4",\n                "children": [\n                  {\n                    "name": "person.last"\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    }\n  },\n  "person": {\n    "ui:field": "LayoutHeaderField"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Passing the above ",(0,t.jsx)(n.code,{children:"uiSchema"})," to the RJSF ",(0,t.jsx)(n.code,{children:"Form"})," you will end up with the following UI:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Person Info\n  First Name*                   Middle Name                   Last Name*\n  +--------------------------+  +--------------------------+  +--------------------------+\n  |                          |  |                          |  |                          |\n  +--------------------------+  +--------------------------+  +--------------------------+\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The above example uses the ",(0,t.jsx)(n.code,{children:"core"})," UI theme's ",(0,t.jsx)(n.code,{children:"Bootstrap 3"})," grid classes to make the ",(0,t.jsx)(n.code,{children:"Person Info"}),' span 12 columns within\na row and each of the person name fields span 4 columns within a row. It also adds the "row" grid class to the outermost\n',(0,t.jsx)(n.code,{children:"ui:row"})," to make whole UI be part of a grid row."]}),"\n",(0,t.jsxs)(n.p,{children:["Now sometimes, depending on the grid system, you don't need to explicitly define both second-level rows, instead\ndepending on the column grid behavior. Luckily the ",(0,t.jsx)(n.code,{children:"core"})," theme's grid system is one of those, so the following UI\nschema will also produce the exact same result."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "row",\n      "children": [\n        {\n          "ui:col": {\n            "className": "col-xs-12",\n            "children": ["person"]\n          }\n        },\n        {\n          "ui:columns": {\n            "className": "col-xs-4",\n            "children": ["person.first", "person.middle", "person.last"]\n          }\n        }\n      ]\n    }\n  },\n  "person": {\n    "ui:field": "LayoutHeaderField"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here is how the ",(0,t.jsx)(n.code,{children:"LayoutGridField"}),' "syntax" above is used.']}),"\n",(0,t.jsxs)(n.h3,{id:"ui-part-2",children:["ui",":row",", part 2"]}),"\n",(0,t.jsxs)(n.p,{children:["As the above examples show, the ",(0,t.jsx)(n.code,{children:"ui:row"})," object can be nested inside of the ",(0,t.jsx)(n.code,{children:"children"})," of a ",(0,t.jsx)(n.code,{children:"ui:row"}),". This signifies the\nnesting of one row inside another row. It also shows that any additional properties added to the ",(0,t.jsx)(n.code,{children:"ui:row"})," object, in this\ncase the ",(0,t.jsx)(n.code,{children:'"className": "row"'})," will be spread onto the underlying theme's grid implementation. You may also pass other\nproperties, such as ",(0,t.jsx)(n.code,{children:"style"})," blocks or, in the case of other themes, properties that will affect the underlying grid system\ncomponents."]}),"\n",(0,t.jsxs)(n.h3,{id:"ui-1",children:["ui",":col"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ui:col"}),' "syntax" represents a single column of data in the grid. Like ',(0,t.jsx)(n.code,{children:"ui:row"})," this syntax will spread the\n",(0,t.jsx)(n.code,{children:'"className": "col-xs-12"'})," and ",(0,t.jsx)(n.code,{children:'"className": "col-xs-4"'})," properties onto the underlying theme's grid implementation, as\nwell as any other properties, such as ",(0,t.jsx)(n.code,{children:"style"})," blocks, etc. In its most compact form, the ",(0,t.jsx)(n.code,{children:"ui:col"})," can be written as\n",(0,t.jsx)(n.code,{children:'{ "ui:col": ["person"] }'}),", in a manner similar to ",(0,t.jsx)(n.code,{children:"ui:row"})," where the array is implicitly assumed to be the ",(0,t.jsx)(n.code,{children:"children"}),"\nproperty."]}),"\n",(0,t.jsxs)(n.p,{children:["In its most expanded form, the ",(0,t.jsx)(n.code,{children:"ui:col"})," contains an array of ",(0,t.jsx)(n.code,{children:"children"})," in the form of objects with ",(0,t.jsx)(n.code,{children:'"name": "<field id>"'}),"\nas the minimum required property. Any additional properties added within the object will be passed along to the\nunderlying ",(0,t.jsx)(n.code,{children:"Widget"})," implementation in the ",(0,t.jsx)(n.code,{children:"ui:options"})," portion of the ",(0,t.jsx)(n.code,{children:"uiSchema"}),". This allows for fine-tuning any\nout-of-the-box or custom widgets. Let's take a look at an example where the ",(0,t.jsx)(n.code,{children:"Middle Name"})," column hides its label adding\na margin to take up the space once occupied by the label, and is reduced in size relative to the ",(0,t.jsx)(n.code,{children:"First Name"})," and\n",(0,t.jsx)(n.code,{children:"Last Name"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "row",\n      "children": [\n        {\n          "ui:row": [\n            {\n              "ui:col": {\n                "className": "col-xs-12",\n                "children": ["person"]\n              }\n            }\n          ]\n        },\n        {\n          "ui:row": [\n            {\n              "ui:col": {\n                "className": "col-xs-5",\n                "children": ["person.first"]\n              }\n            },\n            {\n              "ui:col": {\n                "className": "col-xs-2",\n                "style": {\n                  "margin-top": "25px"\n                },\n                "children": [\n                  {\n                    "name": "person.middle",\n                    "label": false\n                  }\n                ]\n              }\n            },\n            {\n              "ui:col": {\n                "className": "col-xs-5",\n                "children": ["person.last"]\n              }\n            }\n          ]\n        }\n      ]\n    }\n  },\n  "person": {\n    "ui:field": "LayoutHeaderField"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Passing the above ",(0,t.jsx)(n.code,{children:"uiSchema"})," to the RJSF ",(0,t.jsx)(n.code,{children:"Form"})," you will end up with the following UI:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Person Info\n  First Name*                                      Last Name*\n  +--------------------------------+  +---------+  +--------------------------------+\n  |                                |  |         |  |                                |\n  +--------------------------------+  +---------+  +--------------------------------+\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"ui-2",children:["ui",":columns"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ui:columns"}),' "syntax" represents a group of columns in the grid. Like ',(0,t.jsx)(n.code,{children:"ui:row"})," and ",(0,t.jsx)(n.code,{children:"ui:col"})," this syntax will spread\nthe properties onto the underlying theme's grid implementation (in an earlier example ",(0,t.jsx)(n.code,{children:'"className": "col-xs-4"'})," ), as\nwell as any other properties, such as ",(0,t.jsx)(n.code,{children:"style"})," blocks, etc. It is short-hand notation for rendering a group of columns\nall with the same grid system properties. As shown in the above examples, the set of three ",(0,t.jsx)(n.code,{children:"ui:col"})," definitions for\nfirst, middle and last names are the same as the single ",(0,t.jsx)(n.code,{children:"ui:columns"})," definition with all three listed as children."]}),"\n",(0,t.jsxs)(n.p,{children:["In its most compact form, the ",(0,t.jsx)(n.code,{children:"ui:col"})," can be written as ",(0,t.jsx)(n.code,{children:'{ "ui:columns": ["person.first", "person.last"] }'}),", in a\nmanner similar ",(0,t.jsx)(n.code,{children:"ui:row"})," and ",(0,t.jsx)(n.code,{children:"ui:col"})," where the array is implicitly assumed to be the ",(0,t.jsx)(n.code,{children:"children"})," property. The\n",(0,t.jsx)(n.code,{children:"ui:columns"})," syntax also supports ",(0,t.jsx)(n.code,{children:"children"})," in the form of objects with ",(0,t.jsx)(n.code,{children:'"name": "<field id>"'})," as the minimum required\nproperty, passing along any additional properties to the underlying ",(0,t.jsx)(n.code,{children:"Widget"})," as ",(0,t.jsx)(n.code,{children:"ui:options"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"gridtemplate",children:"GridTemplate"}),"\n",(0,t.jsxs)(n.p,{children:["The concept of a theme's grid system has been mentioned several times in the documentation so far. Remember that each\ntheme's grid system is unique to that theme. It is essential to understand how your theme's grid system works in order\nto know how to write the ",(0,t.jsx)(n.code,{children:"uiSchema"})," to get the grid layout you want for your fields."]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to know how your theme implements its grid system, take a look at the ",(0,t.jsx)(n.code,{children:"GridTemplate"})," source code. You may\nalso override your theme's ",(0,t.jsx)(n.code,{children:"GridTemplate"})," with your own to fine tune how the properties you pass to the ",(0,t.jsx)(n.code,{children:"ui:row"}),", ",(0,t.jsx)(n.code,{children:"ui:col"}),",\nand ",(0,t.jsx)(n.code,{children:"ui:columns"})," are handled. Each ",(0,t.jsx)(n.code,{children:"ui:row"})," and ",(0,t.jsx)(n.code,{children:"ui:col"})," will render a ",(0,t.jsx)(n.code,{children:"GridTemplate"})," passing ",(0,t.jsx)(n.code,{children:"column: false"})," for ",(0,t.jsx)(n.code,{children:"ui:row"}),"\nand ",(0,t.jsx)(n.code,{children:"column: true"})," for ",(0,t.jsx)(n.code,{children:"ui:col"}),". The ",(0,t.jsx)(n.code,{children:"ui:columns"})," syntax will render a ",(0,t.jsx)(n.code,{children:"GridTemplate"})," around each of the ",(0,t.jsx)(n.code,{children:"children"}),". Any\nadditional properties besides ",(0,t.jsx)(n.code,{children:"children"})," will be directly passed to the ",(0,t.jsx)(n.code,{children:"GridTemplate"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-layoutgridfield-to-render-fields-conditionally",children:"Defining the LayoutGridField to render fields conditionally"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"GridLayoutField"})," also supports the concept of conditionally rendering a set of fields based upon the value(s) of\nanother field within the ",(0,t.jsx)(n.code,{children:"formData"}),". Because the layout grid works on a field-by-field basis, it treats the render of a\n",(0,t.jsx)(n.code,{children:"anyOf"})," or ",(0,t.jsx)(n.code,{children:"oneOf"})," field differently. It presents to the user ONLY the checkbox group (anyOf) or radio button group\n(oneOf). In order to render any nested fields associated with them, one has to explicitly specify them in the ",(0,t.jsx)(n.code,{children:"uiSchema"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For the purposes of demonstrating the feature, let's work with a ",(0,t.jsx)(n.code,{children:"schema"})," containing a fairly simple ",(0,t.jsx)(n.code,{children:"oneOf"})," field with\nnested objects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "type": "object",\n  "properties": {\n    "name": {\n      "title": "My Name",\n      "type": "string"\n    },\n    "favorite": {\n      "title": "My Favorite Shape",\n      "discriminator": {\n        "propertyName": "shape"\n      },\n      "oneOf": [\n        {\n          "type": "object",\n          "properties": {\n            "shape": {\n              "title": "Line",\n              "type": "string",\n              "const": "line"\n            },\n            "length": {\n              "title": "Line Length",\n              "type": "number"\n            }\n          },\n          "required": ["shape", "length"]\n        },\n        {\n          "type": "object",\n          "properties": {\n            "shape": {\n              "title": "Circle",\n              "type": "string",\n              "const": "circle"\n            },\n            "radius": {\n              "title": "Radius",\n              "type": "number"\n            }\n          },\n          "required": ["shape", "radius"]\n        },\n        {\n          "type": "object",\n          "properties": {\n            "shape": {\n              "title": "Polygon",\n              "type": "string",\n              "const": "polygon"\n            },\n            "sides": {\n              "title": "# of Sides",\n              "type": "number",\n              "minimum": 3,\n              "default": 3\n            },\n            "length": {\n              "title": "Side Length",\n              "type": "number"\n            }\n          },\n          "required": ["shape", "sides"]\n        }\n      ]\n    }\n  },\n  "required": ["name"]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you were to pass this ",(0,t.jsx)(n.code,{children:"schema"})," to the RJSF ",(0,t.jsx)(n.code,{children:"Form"})," you will end up with the following UI, shown here as a simple ASCII\ndrawing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"My Favorite Shape\n  My Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  My Favorite Shape\n    +--------------------------------------------------------------------------+\n    | My Favorite Shape option 1                                             v |\n    +--------------------------------------------------------------------------+\n\n   Favorite\n    Line*\n    +--------------------------------------------------------------------------+\n    | line                                                                     |\n    +--------------------------------------------------------------------------+\n\n    Line Length*\n    +--------------------------------------------------------------------------+\n    |                                                                          |\n    +--------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The second input is a dropdown with the values ",(0,t.jsx)(n.code,{children:"My Favorite Shape option 1"}),", ",(0,t.jsx)(n.code,{children:"My Favorite Shape option 2"})," and\n",(0,t.jsx)(n.code,{children:"My Favorite Shape option 3"}),". When you change the dropdown the other fields below it change to match the objects within\nthe ",(0,t.jsx)(n.code,{children:"oneOf"})," as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"My Favorite Shape\n  My Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  My Favorite Shape\n    +--------------------------------------------------------------------------+\n    | My Favorite Shape option 2                                             v |\n    +--------------------------------------------------------------------------+\n\n   Favorite\n    Circle*\n    +--------------------------------------------------------------------------+\n    | cirle                                                                    |\n    +--------------------------------------------------------------------------+\n\n    Radius*\n    +--------------------------------------------------------------------------+\n    |                                                                          |\n    +--------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"My Favorite Shape\n  My Name*\n  +------------------------------------------------------------------------------+\n  |                                                                              |\n  +------------------------------------------------------------------------------+\n\n  My Favorite Shape\n    +--------------------------------------------------------------------------+\n    | My Favorite Shape option 3                                             v |\n    +--------------------------------------------------------------------------+\n\n   Favorite\n    Polygon*\n    +--------------------------------------------------------------------------+\n    | polygon                                                                  |\n    +--------------------------------------------------------------------------+\n\n    # of Sides*\n    +--------------------------------------------------------------------------+\n    | 3                                                                        |\n    +--------------------------------------------------------------------------+\n\n    Side Length\n    +--------------------------------------------------------------------------+\n    |                                                                          |\n    +--------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: The ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," does not currently work with a root-level ",(0,t.jsx)(n.code,{children:"anyOf"})," or ",(0,t.jsx)(n.code,{children:"oneOf"})," object since it requires that\neverything being displayed in have a field id and they don't."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Now let's add a ",(0,t.jsx)(n.code,{children:"uiSchema"})," that will allow us to create a much more pleasing UI where the dropdown contains the actual\n",(0,t.jsx)(n.code,{children:"oneOf"})," values and the fields all show up on the side of the dropdown:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "row",\n      "children": [\n        {\n          "ui:col": {\n            "className": "col-xs-12",\n            "children": ["name"]\n          }\n        },\n        {\n          "ui:col": {\n            "className": "col-xs-4",\n            "children": ["favorite"]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "line",\n            "operator": "all",\n            "children": [\n              {\n                "ui:col": {\n                  "className": "col-xs-4",\n                  "children": ["favorite.length"]\n                }\n              }\n            ]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "circle",\n            "operator": "all",\n            "children": [\n              {\n                "ui:col": {\n                  "className": "col-xs-4",\n                  "children": ["favorite.radius"]\n                }\n              }\n            ]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "polygon",\n            "operator": "all",\n            "children": [\n              {\n                "ui:columns": {\n                  "className": "col-xs-4",\n                  "children": ["favorite.sides", "favorite.length"]\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  },\n  "favorite": {\n    "ui:widget": "select"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This results in the following UI using the ",(0,t.jsx)(n.code,{children:"core"})," theme via the ",(0,t.jsx)(n.code,{children:"Bootstrap 3"})," grid system:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"  My Name*\n  +--------------------------------------------------------------------------------------+\n  |                                                                                      |\n  +--------------------------------------------------------------------------------------+\n\n  My Favorite Shape*            Line Length*\n  +--------------------------+  +--------------------------+\n  | Line                   v |  |                          |\n  +--------------------------+  +--------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"  My Name*\n  +--------------------------------------------------------------------------------------+\n  |                                                                                      |\n  +--------------------------------------------------------------------------------------+\n\n  My Favorite Shape*            Radius*\n  +--------------------------+  +--------------------------+\n  | Circle                 v |  |                          |\n  +--------------------------+  +--------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"  My Name*\n  +--------------------------------------------------------------------------------------+\n  |                                                                                      |\n  +--------------------------------------------------------------------------------------+\n\n  My Favorite Shape*            # of Sides*                   Side Length\n  +--------------------------+  +--------------------------+  +--------------------------+\n  | Polygon                v |  | 3                        |  |                          |\n  +--------------------------+  +--------------------------+  +--------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"As mentioned before, another theme's grid system may render the above example differently."}),"\n",(0,t.jsxs)(n.h3,{id:"ui-3",children:["ui",":condition"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ui:condition"}),' "syntax" represents conditional rendering of data in the grid. The condition has four required\nproperties, ',(0,t.jsx)(n.code,{children:"field"}),", ",(0,t.jsx)(n.code,{children:"value"}),", ",(0,t.jsx)(n.code,{children:"operator"})," and ",(0,t.jsx)(n.code,{children:"children"}),". Let's talk about each in turn."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"field"}),": The dotted-path name of a leaf-level field that makes up the left-side of the condition, used to get data from the ",(0,t.jsx)(n.code,{children:"formData"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"}),": A single value or a list of values that make up the right-side of the condition"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"operator"}),": One of the following three options that controls how the left and right sides of the condition are compared","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"all"}),": This operator will pass when the right-side and left-side contains all the same value(s)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"some"}),": This operator will pass when the right-side and left-side contain as least one value in common"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"none"}),": This operator will pass when the right-side and left-side do not contain any values in common"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"children"}),": The list of ",(0,t.jsx)(n.code,{children:"ui:row"}),", ",(0,t.jsx)(n.code,{children:"ui:col"})," or ",(0,t.jsx)(n.code,{children:"ui:columns"})," definitions to display when the condition is true"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, when the ",(0,t.jsx)(n.code,{children:"favorite.shape"})," field value is ",(0,t.jsx)(n.code,{children:"line"})," then the ",(0,t.jsx)(n.code,{children:"favorite.length"})," field is displayed in\nthe grid spanning 4 columns. When it is ",(0,t.jsx)(n.code,{children:"circle"}),", then ",(0,t.jsx)(n.code,{children:"favorite.radius"})," is displayed in the grid spanning 4 columns.\nWhen it is ",(0,t.jsx)(n.code,{children:"polygon"}),", then ",(0,t.jsx)(n.code,{children:"favorite.sides"})," and ",(0,t.jsx)(n.code,{children:"favorite.length"})," are displayed in the grid, each spanning 4 columns."]}),"\n",(0,t.jsxs)(n.p,{children:["We leave it up to the reader to create other examples that use different ",(0,t.jsx)(n.code,{children:"operator"}),"s."]}),"\n",(0,t.jsx)(n.h2,{id:"other-capabilities-of-the-layoutgridfield",children:"Other capabilities of the LayoutGridField"}),"\n",(0,t.jsxs)(n.p,{children:["There are a few more small features that the ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," supports. First, there is a ",(0,t.jsx)(n.code,{children:"FormContext"})," named lookup\ncapability that allows one to provide a name-mapped set of strings, components and functions in the ",(0,t.jsx)(n.code,{children:"FormContext"})," inside\nof a well-known location, ",(0,t.jsx)(n.code,{children:"layoutGridLookupMap"})," and then reference those names within the ",(0,t.jsx)(n.code,{children:"uiSchema"}),'. Second, the grid\nrendering code recognizes an alternate "syntax" for the objects in ',(0,t.jsx)(n.code,{children:"children"})," arrays in order to display any random\nReact element within a grid. Below are examples of them both."]}),"\n",(0,t.jsx)(n.h3,{id:"named-lookup-support-for-classname",children:"Named lookup support for className"}),"\n",(0,t.jsxs)(n.p,{children:["Since some themes, like ",(0,t.jsx)(n.code,{children:"mui"}),", support CSS-in-JS class names, one cannot hard-code the actual ",(0,t.jsx)(n.code,{children:"className"})," in the\n",(0,t.jsx)(n.code,{children:"uiSchema"})," easily. That is where the name-mapped information in the ",(0,t.jsx)(n.code,{children:"FormContext"})," comes into play. Let's assume that\nyou are using a theme like ",(0,t.jsx)(n.code,{children:"mui"})," and you need to style a ",(0,t.jsx)(n.code,{children:"Grid"})," using CSS-in-JS you could do something like the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:"uiSchema.json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "GridStyle anotherClass",\n      "children": ["person.last", "person.first"]\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { styled, Grid } from '@mui/material';\nimport Form from '@rjsf/core';\nimport { LOOKUP_MAP_NAME, FormContextType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\n// Import the Person Info schema from above\nimport schema from './personSchema.json';\n// Import the UI Schema from the file above\nimport uiSchema from './uiSchema.json';\n\nconst css = {\n  STYLED_GRID: 'StyledGrid',\n};\n\n// Define the style\nconst StyledGrid = styled(Grid)`\n  ${`& .${css.STYLED_GRID}`} {\n    p {\n      /* Override default presentation of <p> tags within a grid  */\n      font-weight: bold\n      color: dark-purple !important;\n    }\n  }\n`;\n\n// Add the style to the `LOOKUP_MAP_NAME` that the `LayoutGridField` uses\nconst formContext: FormContextType = {\n  [LOOKUP_MAP_NAME]: {\n    GridStyle: css.STYLED_GRID,\n  },\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} formContext={formContext} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see in the example, we've created a ",(0,t.jsx)(n.code,{children:"FormContext"})," that has the named-lookup map containing the\n",(0,t.jsx)(n.code,{children:"css.STYLED_GRID"})," object mapped to ",(0,t.jsx)(n.code,{children:"GridStyle"}),". In the ",(0,t.jsx)(n.code,{children:"uiSchema"})," we then add ",(0,t.jsx)(n.code,{children:"GridStyle"})," as the ",(0,t.jsx)(n.code,{children:"className"})," for the\ngrid rows. Under the hood, the ",(0,t.jsx)(n.code,{children:"LayoutGridField"})," automatically goes through the ",(0,t.jsx)(n.code,{children:"className"})," props and does a lookup of\neach class name in the ",(0,t.jsx)(n.code,{children:"FormContext"}),", replacing the ",(0,t.jsx)(n.code,{children:"GridStyle"})," with the generated ",(0,t.jsx)(n.code,{children:"css.GRID_STYLE"})," name. And because the\nother class name in the example, ",(0,t.jsx)(n.code,{children:"anotherClass"}),", is not mapped in the named-lookup map, it will passed to the\n",(0,t.jsx)(n.code,{children:"GridTemplate"})," as is. In summary, if the CSS-in-JS class is called ",(0,t.jsx)(n.code,{children:"StyledGrid-1asd123"})," then the ",(0,t.jsx)(n.code,{children:"className"})," property\npassed to the ",(0,t.jsx)(n.code,{children:"GridTemplate"})," will be ",(0,t.jsx)(n.code,{children:'"StyledGrid-1asd123 anotherClass"'}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"rendering-a-custom-react-element-in-the-grid",children:"Rendering a custom React element in the grid"}),"\n",(0,t.jsxs)(n.p,{children:["Because you have full control of how you layout your components in the grid, what do you do when you want to add an\nelement to your presentation that isn't directly associated with a ",(0,t.jsx)(n.code,{children:"schema"}),', like say an image? Well, that is actually\nreally easy using a variant of the "syntax" for a ',(0,t.jsx)(n.code,{children:"children"})," node in the ",(0,t.jsx)(n.code,{children:"uiSchema"}),". Here's how:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:"shapeUiSchema.json",children:'{\n  "ui:field": "LayoutGridField",\n  "ui:layoutGrid": {\n    "ui:row": {\n      "className": "row",\n      "children": [\n        {\n          "ui:col": {\n            "className": "col-xs-12",\n            "children": ["name"]\n          }\n        },\n        {\n          "ui:col": {\n            "className": "col-xs-4",\n            "children": ["favorite"]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "line",\n            "operator": "all",\n            "children": [\n              {\n                "ui:col": {\n                  "className": "col-xs-2",\n                  "children": [\n                    {\n                      "name": "",\n                      "render": "LineImageComponent",\n                      "size": "small-size"\n                    }\n                  ]\n                }\n              },\n              {\n                "ui:col": {\n                  "className": "col-xs-4",\n                  "children": ["favorite.length"]\n                }\n              }\n            ]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "circle",\n            "operator": "all",\n            "children": [\n              {\n                "ui:col": {\n                  "className": "col-xs-2",\n                  "children": [\n                    {\n                      "name": "",\n                      "render": "CircleImageComponent",\n                      "size": "small-size"\n                    }\n                  ]\n                }\n              },\n              {\n                "ui:col": {\n                  "className": "col-xs-4",\n                  "children": ["favorite.radius"]\n                }\n              }\n            ]\n          }\n        },\n        {\n          "ui:condition": {\n            "field": "favorite.shape",\n            "value": "polygon",\n            "operator": "all",\n            "children": [\n              {\n                "ui:col": {\n                  "className": "col-xs-2",\n                  "children": [\n                    {\n                      "name": "",\n                      "render": "PolygonImageComponent",\n                      "size": "small-size"\n                    }\n                  ]\n                }\n              },\n              {\n                "ui:columns": {\n                  "className": "col-xs-3",\n                  "children": ["favorite.sides", "favorite.length"]\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  },\n  "favorite": {\n    "ui:widget": "select"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import Form from '@rjsf/core';\nimport { LOOKUP_MAP_NAME, FormContextType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\n// Import the My Favorite Shape schema from above section\nimport schema from './shapeSchema.json';\n// Import the UI Schema from the file above\nimport uiSchema from './shapeUiSchema.json';\n// Now import my 3 shape React components\nimport { LineShape, CircleShape, PolygonShape } from './myShapes';\n\n// Add the style to the `LOOKUP_MAP_NAME` that the `LayoutGridField` uses\nconst formContext: FormContextType = {\n  [LOOKUP_MAP_NAME]: {\n    LineImageComponent: LineShape,\n    CircleImageComponent: CircleShape,\n    PolygonImageComponent: PolygonShape,\n  },\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} formContext={formContext} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see in the example, we've created a ",(0,t.jsx)(n.code,{children:"FormContext"})," that contains the named-lookup map containing the three\ncomponents (",(0,t.jsx)(n.code,{children:"LineShape"}),", ",(0,t.jsx)(n.code,{children:"CircleShape"}),", ",(0,t.jsx)(n.code,{children:"PolygonShape"}),") mapped to the lookup keys ",(0,t.jsx)(n.code,{children:"LineImageComponent"}),",\n",(0,t.jsx)(n.code,{children:"CircleImageComponent"}),", ",(0,t.jsx)(n.code,{children:"PolygonImageComponent"})," respectively. In the ",(0,t.jsx)(n.code,{children:"uiSchema"}),", we use the optional ",(0,t.jsx)(n.code,{children:"render"})," property\nin the ",(0,t.jsx)(n.code,{children:"children"}),' object "syntax" to define the lookup name of the component we want to use. The ',(0,t.jsx)(n.code,{children:"LayoutGridField"})," will\nthen do a lookup of the ",(0,t.jsx)(n.code,{children:"render"})," string. If you forget to add the ",(0,t.jsx)(n.code,{children:"formContext"})," or the mapping in the ",(0,t.jsx)(n.code,{children:"LOOKUP_NAME_MAP"}),"\nthen nothing will be rendered."]}),"\n",(0,t.jsxs)(n.p,{children:["If you provide an empty string as the ",(0,t.jsx)(n.code,{children:"name"})," along with the ",(0,t.jsx)(n.code,{children:"render"}),", then your component will be rendered only with any\nadditional properties passed in the ",(0,t.jsx)(n.code,{children:"children"})," object. If you provide a ",(0,t.jsx)(n.code,{children:"name"})," that matches a field in the ",(0,t.jsx)(n.code,{children:"schema"}),",\nthen the ",(0,t.jsx)(n.code,{children:"render"})," component won't be used. Otherwise, the ",(0,t.jsx)(n.code,{children:"render"})," component will be passed all of the ",(0,t.jsx)(n.code,{children:"FieldProp"}),"s,\nincluding the ",(0,t.jsx)(n.code,{children:"schema"}),", ",(0,t.jsx)(n.code,{children:"uiSchema"}),", ",(0,t.jsx)(n.code,{children:"fieldPathId"}),", ",(0,t.jsx)(n.code,{children:"errorSchema"}),", ",(0,t.jsx)(n.code,{children:"formData"}),", ",(0,t.jsx)(n.code,{children:"registry"}),", etc."]}),"\n",(0,t.jsxs)(n.p,{children:["So our example will render the ",(0,t.jsx)(n.code,{children:"LineShape"})," component with ",(0,t.jsx)(n.code,{children:"size: 'small-size'"})," in the second column between the\n",(0,t.jsx)(n.code,{children:"My Favorite Shape"})," dropdown and the ",(0,t.jsx)(n.code,{children:"Line Length"})," input. Also, it will render the ",(0,t.jsx)(n.code,{children:"CircleShape"})," component with\n",(0,t.jsx)(n.code,{children:"size: 'small-size'"})," in the second column between the ",(0,t.jsx)(n.code,{children:"My Favorite Shape"})," dropdown and the ",(0,t.jsx)(n.code,{children:"Radius"})," input. Finally,\nit will render the ",(0,t.jsx)(n.code,{children:"PolygonShape"})," component with ",(0,t.jsx)(n.code,{children:"size: 'small-size'"})," in the second column between the\n",(0,t.jsx)(n.code,{children:"My Favorite Shape"})," dropdown and the ",(0,t.jsx)(n.code,{children:"# of Sides"})," input."]}),"\n",(0,t.jsx)(n.h4,{id:"passing-components-directly-in-uischema",children:"Passing components directly in uiSchema"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"render"}),' "syntax" also works if you have an object-based ',(0,t.jsx)(n.code,{children:"uiSchema"})," and pass the component function directly rather\nthan use a named lookup. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import Form from '@rjsf/core';\nimport { LOOKUP_MAP_NAME, FormContextType, UiSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\n// Import the My Favorite Shape schema from above section\nimport schema from './shapeSchema.json';\n// Now import my 3 shape React components that understand how to extract the props from `formData`\nimport { LineShape, CircleShape, PolygonShape } from './myShapes';\n\nconst uiSchema: UiSchema = {\n  'ui:field': 'LayoutGridField',\n  'ui:layoutGrid': {\n    'ui:row': {\n      className: 'row',\n      children: [\n        {\n          'ui:col': {\n            className: 'col-xs-12',\n            children: ['name'],\n          },\n        },\n        {\n          'ui:col': {\n            className: 'col-xs-4',\n            children: ['favorite'],\n          },\n        },\n        {\n          'ui:condition': {\n            field: 'favorite.shape',\n            value: 'line',\n            operator: 'all',\n            children: [\n              {\n                'ui:col': {\n                  className: 'col-xs-4',\n                  children: ['favorite.length'],\n                },\n              },\n              {\n                'ui:col': {\n                  className: 'col-xs-12',\n                  children: [\n                    {\n                      name: 'lineImage',\n                      render: LineShape,\n                      dataPath: 'favorite.length',\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        },\n        {\n          'ui:condition': {\n            field: 'favorite.shape',\n            value: 'circle',\n            operator: 'all',\n            children: [\n              {\n                'ui:col': {\n                  className: 'col-xs-4',\n                  children: ['favorite.radius'],\n                },\n              },\n              {\n                'ui:col': {\n                  className: 'col-xs-12',\n                  children: [\n                    {\n                      name: 'circleShape',\n                      render: CircleShape,\n                      dataPath: 'favorite.radius',\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        },\n        {\n          'ui:condition': {\n            field: 'favorite.shape',\n            value: 'polygon',\n            operator: 'all',\n            children: [\n              {\n                'ui:columns': {\n                  className: 'col-xs-4',\n                  children: ['favorite.sides', 'favorite.length'],\n                },\n              },\n              {\n                'ui:col': {\n                  className: 'col-xs-12',\n                  children: [\n                    {\n                      name: 'polygonShape',\n                      render: PolygonShape,\n                      dataPaths: ['favorite.sides', 'favorite.length'],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        },\n      ],\n    },\n  },\n  favorite: {\n    'ui:widget': 'select',\n  },\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} formContext={formContext} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's assume that the ",(0,t.jsx)(n.code,{children:"LineShape"}),", ",(0,t.jsx)(n.code,{children:"CircleShape"})," and ",(0,t.jsx)(n.code,{children:"PolygonShape"})," components configured above use the ",(0,t.jsx)(n.code,{children:"dataPath[s]"}),"\nproperty to extract the fields from the ",(0,t.jsx)(n.code,{children:"formData"})," that is being passed to them in order to display the exact size of\nthe shape. The grid above will render the ",(0,t.jsx)(n.code,{children:"*Shape"})," components in a 12-wide column below the field inputs."]}),"\n",(0,t.jsx)(n.h3,{id:"other-named-lookup-situations",children:"Other named lookup situations"}),"\n",(0,t.jsxs)(n.p,{children:["Other ",(0,t.jsx)(n.code,{children:"children"})," properties also do named lookups. In the ",(0,t.jsx)(n.code,{children:"shapeUiSchema.json"})," example above, if the ",(0,t.jsx)(n.code,{children:"*Shape"})," components\nare upgraded to change the input of the ",(0,t.jsx)(n.code,{children:"size"})," prop to have newer values, one could use the ",(0,t.jsx)(n.code,{children:"FormContext"})," to map the\n",(0,t.jsx)(n.code,{children:"small-size"})," value to a newer value. For example, if you wanted to use the new ",(0,t.jsx)(n.code,{children:"medium"})," value for the ",(0,t.jsx)(n.code,{children:"size"})," prop, or\nif you wanted to programmatically control which size to use outside of the ",(0,t.jsx)(n.code,{children:"Form"})," you could update the example as\nfollows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import Form from '@rjsf/core';\nimport { LOOKUP_MAP_NAME, FormContextType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\n// Import the My Favorite Shape schema from above section\nimport schema from './shapeSchema.json';\n// Import the UI Schema from the file above\nimport uiSchema from './shapeUiSchema.json';\n// Now import my 3 shape React components\nimport { LineShape, CircleShape, PolygonShape } from './myShapes';\n\nconst MEDIUM_SIZE = 'medium';\n\n// Add the style to the `LOOKUP_MAP_NAME` that the `LayoutGridField` uses\nconst formContext: FormContextType = {\n  [LOOKUP_MAP_NAME]: {\n    LineImageComponent: LineShape,\n    CircleImageComponent: CircleShape,\n    PolygonImageComponent: PolygonShape,\n    'small-size': MEDIUM_SIZE,\n  },\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} formContext={formContext} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"so-much-flexibility-available",children:"So much flexibility available"}),"\n",(0,t.jsxs)(n.p,{children:["These examples are just a tiny fraction of the ways the ",(0,t.jsx)(n.code,{children:"LayoutGridField"}),' can be used. Remember, understand the theme\'s\ngrid system and the "syntax" described above and ',(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/api-reference/LayoutGridField",children:"here"}),". Play around, you can build\njust about any UI you want and still have it populate the JSON schema's ",(0,t.jsx)(n.code,{children:"formData"}),"!"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ENJOY!!"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);