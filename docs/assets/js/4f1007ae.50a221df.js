"use strict";(self.webpackChunk_rjsf_docs=self.webpackChunk_rjsf_docs||[]).push([[9372],{1184:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>d});var s=i(4041);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},1261:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"advanced-customization/custom-widgets-fields","title":"Custom Widgets and Fields","description":"The API allows to specify your own custom widget and field components:","source":"@site/docs/advanced-customization/custom-widgets-fields.md","sourceDirName":"advanced-customization","slug":"/advanced-customization/custom-widgets-fields","permalink":"/react-jsonschema-form/docs/advanced-customization/custom-widgets-fields","draft":false,"unlisted":false,"editUrl":"https://github.com/rjsf-team/react-jsonschema-form/tree/main/packages/docs/docs/advanced-customization/custom-widgets-fields.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Custom Themes","permalink":"/react-jsonschema-form/docs/advanced-customization/custom-themes"},"next":{"title":"Internals","permalink":"/react-jsonschema-form/docs/advanced-customization/internals"}}');var t=i(1085),o=i(1184);const r={},d="Custom Widgets and Fields",c={},l=[{value:"Customizing the default fields and widgets",id:"customizing-the-default-fields-and-widgets",level:2},{value:"Raising errors from within a custom widget or field",id:"raising-errors-from-within-a-custom-widget-or-field",level:2},{value:"Adding your own custom widgets",id:"adding-your-own-custom-widgets",level:2},{value:"Custom component registration",id:"custom-component-registration",level:3},{value:"Custom widget options",id:"custom-widget-options",level:3},{value:"Customizing widgets&#39; text input",id:"customizing-widgets-text-input",level:3},{value:"Wrapping an existing widget to customize it",id:"wrapping-an-existing-widget-to-customize-it",level:3},{value:"Custom field components",id:"custom-field-components",level:2},{value:"Field props",id:"field-props",level:3},{value:"The <code>registry</code> object",id:"the-registry-object",level:2},{value:"Custom SchemaField",id:"custom-schemafield",level:3},{value:"Custom ArraySchemaField",id:"custom-arrayschemafield",level:3},{value:"Custom Field by Id",id:"custom-field-by-id",level:3},{value:"Wrapping an existing field to customize it",id:"wrapping-an-existing-field-to-customize-it",level:3}];function a(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"custom-widgets-and-fields",children:"Custom Widgets and Fields"})}),"\n",(0,t.jsxs)(n.p,{children:["The API allows to specify your own custom ",(0,t.jsx)(n.em,{children:"widget"})," and ",(0,t.jsx)(n.em,{children:"field"})," components:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.em,{children:"widget"})," represents a HTML tag for the user to enter data, eg. ",(0,t.jsx)(n.code,{children:"input"}),", ",(0,t.jsx)(n.code,{children:"select"}),", etc."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.em,{children:"field"})," usually wraps one or more widgets and most often handles internal field state; think of a field as a form row, including the labels."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"customizing-the-default-fields-and-widgets",children:"Customizing the default fields and widgets"}),"\n",(0,t.jsxs)(n.p,{children:["You can override any default field and widget, including the internal widgets like the ",(0,t.jsx)(n.code,{children:"CheckboxWidget"})," that ",(0,t.jsx)(n.code,{children:"BooleanField"}),"\nrenders for boolean values. You can override any field and widget just by providing the customized fields/widgets in the\n",(0,t.jsx)(n.code,{children:"fields"})," and ",(0,t.jsx)(n.code,{children:"widgets"})," props:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, WidgetProps, RegistryWidgetsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'boolean',\n  default: true,\n};\n\nconst uiSchema: UiSchema = {\n  'ui:widget': 'checkbox',\n};\n\nconst CustomCheckbox = function (props: WidgetProps) {\n  return (\n    <button id='custom' className={props.value ? 'checked' : 'unchecked'} onClick={() => props.onChange(!props.value)}>\n      {String(props.value)}\n    </button>\n  );\n};\n\nconst widgets: RegistryWidgetsType = {\n  CheckboxWidget: CustomCheckbox,\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} widgets={widgets} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows you to create a reusable customized form class with your custom fields and widgets:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RegistryFieldsType, RegistryWidgetsType } from '@rjsf/utils';\nimport { FormProps } from '@rjsf/core';\n\nconst customFields: RegistryFieldsType = { StringField: CustomString };\nconst customWidgets: RegistryWidgetsType = { CheckboxWidget: CustomCheckbox };\n\nfunction MyForm(props: FormProps) {\n  return <Form fields={customFields} widgets={customWidgets} {...props} />;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The default fields you can override are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ArrayField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ArraySchemaField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"BooleanField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DescriptionField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"OneOfField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AnyOfField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"LayoutGridField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"LayoutMultiSchemaField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"LayoutHeaderField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"NullField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"NumberField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ObjectField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SchemaField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"StringField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"TitleField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"UnsupportedField"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The default widgets you can override are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AltDateTimeWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AltDateWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"CheckboxesWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"CheckboxWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ColorWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DateTimeWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DateWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"EmailWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"FileWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"HiddenWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"PasswordWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"RadioWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"RangeWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SelectWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"TextareaWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"TextWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"TimeWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"UpDownWidget"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"URLWidget"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"raising-errors-from-within-a-custom-widget-or-field",children:"Raising errors from within a custom widget or field"}),"\n",(0,t.jsxs)(n.p,{children:["You can raise custom 'live validation' errors by overriding the ",(0,t.jsx)(n.code,{children:"onChange"})," method to provide feedback while users are actively changing the form data.\nNote that these errors are temporary and are not recognized during the form validation process."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["This method of raising errors ",(0,t.jsx)(n.em,{children:"only"})," runs during ",(0,t.jsx)(n.code,{children:"onChange"}),", i.e. when the user is changing data. This will not catch errors ",(0,t.jsx)(n.code,{children:"onSubmit"}),", i.e when submitting the form.\nIf you wish to add generic validation logic for your component, you should use the ",(0,t.jsxs)(n.a,{href:"/react-jsonschema-form/docs/api-reference/form-props#customvalidate",children:[(0,t.jsx)(n.code,{children:"customValidate"})," Form prop"]}),"."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { ErrorSchema, RJSFSchema, UiSchema, WidgetProps, RegistryWidgetsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'text',\n  default: 'hello',\n};\n\nconst uiSchema: UiSchema = {\n  'ui:widget': 'text',\n};\n\nconst CustomTextWidget = function (props: WidgetProps) {\n  const { id, value } = props;\n  const raiseErrorOnChange = ({ target: { value } }: ChangeEvent<HTMLInputElement>) => {\n    let raiseError: ErrorSchema | undefined;\n    if (value !== 'test') {\n      raiseError = {\n        __errors: ['Value must be \"test\"'],\n      };\n    }\n    props.onChange(value, [], raiseError, id);\n  };\n\n  return <input id={id} onChange={raiseErrorOnChange} value={value || ''} />;\n};\n\nconst widgets: RegistryWidgetsType = {\n  TextWidget: CustomTextWidget,\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} widgets={widgets} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This creates a custom text widget that raises an error if the input value does not match 'test'."}),"\n",(0,t.jsx)(n.h2,{id:"adding-your-own-custom-widgets",children:"Adding your own custom widgets"}),"\n",(0,t.jsx)(n.p,{children:"You can provide your own custom widgets to a uiSchema for the following json data types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"string"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"number"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"integer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"boolean"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"array"})}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, WidgetProps } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: Schema = {\n  type: 'string',\n};\n\nconst uiSchema: UiSchema = {\n  'ui:widget': (props: WidgetProps) => {\n    return (\n      <input\n        type='text'\n        className='custom'\n        value={props.value}\n        required={props.required}\n        onChange={(event) => props.onChange(event.target.value)}\n      />\n    );\n  },\n};\n\nrender(<Form schema={schema} uiSchema={uiSchema} validator={validator} />, document.getElementById('app'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following props are passed to custom widget components:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"}),": The generated id for this widget, used to provide unique ",(0,t.jsx)(n.code,{children:"name"}),"s and ",(0,t.jsx)(n.code,{children:"id"}),"s for the HTML field elements rendered by widgets;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"}),": The unique name of the field, usually derived from the name of the property in the JSONSchema; Provided in support of custom widgets;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"schema"}),": The JSONSchema subschema object for this widget;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"uiSchema"}),": The uiSchema for this widget;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"}),": The current value for this widget;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"placeholder"}),": The placeholder for the widget, if any;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"required"}),": The required status of this widget;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"disabled"}),": A boolean value stating if the widget is disabled;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"readonly"}),": A boolean value stating if the widget is read-only;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"autofocus"}),": A boolean value stating if the widget should autofocus;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"label"}),": The computed label for this widget, as a string"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hideLabel"}),": A boolean value, if true, will cause the label to be hidden. This is useful for nested fields where you don't want to clutter the UI. Customized via ",(0,t.jsx)(n.code,{children:"label"})," in the ",(0,t.jsx)(n.code,{children:"UiSchema"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"multiple"}),": A boolean value stating if the widget can accept multiple values;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onChange"}),": The value change event handler; call it with the new value every time it changes;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onKeyChange"}),": The key change event handler (only called for fields with ",(0,t.jsx)(n.code,{children:"additionalProperties"}),"); pass the new value every time it changes;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onBlur"}),": The input blur event handler; call it with the widget id and value;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onFocus"}),": The input focus event handler; call it with the widget id and value;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"options"}),": A map of options passed as a prop to the component (see ",(0,t.jsx)(n.a,{href:"#custom-widget-options",children:"Custom widget options"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"options.enumOptions"}),": For enum fields, this property contains the list of options for the enum as an array of { label, value } objects. If the enum is defined using the oneOf/anyOf syntax, the entire schema object for each option is appended onto the { schema, label, value } object."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"formContext"}),": The ",(0,t.jsx)(n.code,{children:"formContext"})," object that you passed to ",(0,t.jsx)(n.code,{children:"Form"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rawErrors"}),": An array of strings listing all generated error messages from encountered errors for this widget."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"registry"}),": A ",(0,t.jsx)(n.a,{href:"#the-registry-object",children:"registry"})," object (read next)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"custom-component-registration",children:"Custom component registration"}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, you can register them all at once by passing the ",(0,t.jsx)(n.code,{children:"widgets"})," prop to the ",(0,t.jsx)(n.code,{children:"Form"})," component, and reference their identifier from the ",(0,t.jsx)(n.code,{children:"uiSchema"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, WidgetProps, RegistryWidgetsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst MyCustomWidget = (props: WidgetProps) => {\n  return (\n    <input\n      type='text'\n      className='custom'\n      value={props.value}\n      required={props.required}\n      onChange={(event) => props.onChange(event.target.value)}\n    />\n  );\n};\n\nconst widgets: RegistryWidgetsType = {\n  myCustomWidget: MyCustomWidget,\n};\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nconst uiSchema: UiSchema = {\n  'ui:widget': 'myCustomWidget',\n};\n\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} widgets={widgets} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is useful if you expose the ",(0,t.jsx)(n.code,{children:"uiSchema"})," as pure JSON, which can't carry functions."]}),"\n",(0,t.jsx)(n.h3,{id:"custom-widget-options",children:"Custom widget options"}),"\n",(0,t.jsxs)(n.p,{children:["If you need to pass options to your custom widget, you can add a ",(0,t.jsx)(n.code,{children:"ui:options"})," object containing those properties. If the widget has ",(0,t.jsx)(n.code,{children:"defaultProps"}),", the options will be merged with the (optional) options object from ",(0,t.jsx)(n.code,{children:"defaultProps"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, WidgetProps } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nfunction MyCustomWidget(props: WidgetProps) {\n  const { options } = props;\n  const { color, backgroundColor } = options;\n  return <input style={{ color, backgroundColor }} />;\n}\n\nMyCustomWidget.defaultProps = {\n  options: {\n    color: 'red',\n  },\n};\n\nconst uiSchema: UiSchema = {\n  'ui:widget': MyCustomWidget,\n  'ui:options': {\n    backgroundColor: 'yellow',\n  },\n};\n\n// renders red on yellow input\nrender(<Form schema={schema} uiSchema={uiSchema} validator={validator} />, document.getElementById('app'));\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Note: This also applies to ",(0,t.jsx)(n.a,{href:"#custom-component-registration",children:"registered custom components"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"customizing-widgets-text-input",children:"Customizing widgets' text input"}),"\n",(0,t.jsxs)(n.p,{children:["All the widgets that render a text input use the ",(0,t.jsx)(n.code,{children:"BaseInputTemplate"})," component internally. If you need to customize all text inputs without customizing all widgets individually, you can provide a ",(0,t.jsx)(n.code,{children:"BaseInputTemplate"})," component in the ",(0,t.jsx)(n.code,{children:"templates"})," property of ",(0,t.jsx)(n.code,{children:"Form"})," (see ",(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/advanced-customization/custom-templates#baseinputtemplate",children:"Custom Templates"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"wrapping-an-existing-widget-to-customize-it",children:"Wrapping an existing widget to customize it"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes you just need to customize the properties that are passed to an existing widget.\nThe way to do this varies based upon whether you are using core or some other theme (such as mui)."}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example of modifying the ",(0,t.jsx)(n.code,{children:"SelectWidget"})," to change the ordering of ",(0,t.jsx)(n.code,{children:"enumOptions"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { WidgetProps } from '@rjsf/utils';\nimport { getDefaultRegistry } from '@rjsf/core';\nimport { Widgets } from '@rjsf/mui';\n\nimport myOptionsOrderFunction from './myOptionsOrderFunction';\n\nconst {\n  widgets: { SelectWidget },\n} = getDefaultRegistry(); // To get widgets from core\n// const { SelectWidget } = Widgets; // To get widgets from a theme do this\n\nfunction MySelectWidget(props: WidgetProps) {\n  const { options } = props;\n  let { enumOptions } = options;\n  // Reorder the `enumOptions` however you want\n  enumOptions = myOptionsOrderFunction(enumOptions);\n  return <SelectWidget {...props} options={{ ...options, enumOptions }} />;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"custom-field-components",children:"Custom field components"}),"\n",(0,t.jsxs)(n.p,{children:["You can provide your own field components to a uiSchema for basically any json schema data type, by specifying a ",(0,t.jsx)(n.code,{children:"ui:field"})," property."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, let's create and register a dumb ",(0,t.jsx)(n.code,{children:"geo"})," component handling a ",(0,t.jsx)(n.em,{children:"latitude"})," and a ",(0,t.jsx)(n.em,{children:"longitude"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, FieldProps, RegistryFieldsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  required: ['lat', 'lon'],\n  properties: {\n    lat: { type: 'number' },\n    lon: { type: 'number' },\n  },\n};\n\n// Define a custom component for handling the root position object\nclass GeoPosition extends React.Component<FieldProps> {\n  constructor(props: FieldProps) {\n    super(props);\n    this.state = { ...props.formData };\n  }\n\n  onChange(name) {\n    return (event) => {\n      this.setState(\n        {\n          [name]: parseFloat(event.target.value),\n        },\n        () => this.props.onChange(this.state),\n      );\n    };\n  }\n\n  render() {\n    const { lat, lon } = this.state;\n    return (\n      <div>\n        <input type='number' value={lat} onChange={this.onChange('lat')} />\n        <input type='number' value={lon} onChange={this.onChange('lon')} />\n      </div>\n    );\n  }\n}\n\n// Define the custom field component to use for the root object\nconst uiSchema: UiSchema = { 'ui:field': 'geo' };\n\n// Define the custom field components to register; here our \"geo\"\n// custom field component\nconst fields: RegistryFieldsType = { geo: GeoPosition };\n\n// Render the form with all the properties we just defined passed\n// as props\nrender(\n  <Form schema={schema} uiSchema={uiSchema} validator={validator} fields={fields} />,\n  document.getElementById('app'),\n);\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Note: Registered fields can be reused across the entire schema."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"field-props",children:"Field props"}),"\n",(0,t.jsx)(n.p,{children:"A field component will always be passed the following props:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"schema"}),": The JSON subschema object for this field;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"uiSchema"}),": The ",(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/api-reference/uiSchema",children:"uiSchema"})," for this field;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idSchema"}),": The tree of unique ids for every child field;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"formData"}),": The data for this field;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"errorSchema"}),": The tree of errors for this field and its children;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"registry"}),": A ",(0,t.jsx)(n.a,{href:"#the-registry-object",children:"registry"})," object (read next)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"formContext"}),": A ",(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/api-reference/form-props#formcontext",children:"formContext"})," object (read next)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"required"}),": The required status of this field;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"disabled"}),": A boolean value stating if the field is disabled;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"readonly"}),": A boolean value stating if the field is read-only;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"autofocus"}),": A boolean value stating if the field should autofocus;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"}),": The unique name of the field, usually derived from the name of the property in the JSONSchema"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idPrefix"}),": To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids; Default is ",(0,t.jsx)(n.code,{children:"root"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"idSeparator"}),": To avoid using a path separator that is present in field names, it is possible to change the separator used for ids (Default is ",(0,t.jsx)(n.code,{children:"_"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rawErrors"}),": `An array of strings listing all generated error messages from encountered errors for this field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onChange"}),": The field change event handler; called with the updated field value, the optional change path for the value (defaults to an empty array), an optional ErrorSchema and the optional id of the field being changed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onBlur"}),": The input blur event handler; call it with the field id and value;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"onFocus"}),": The input focus event handler; call it with the field id and value;"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"the-registry-object",children:["The ",(0,t.jsx)(n.code,{children:"registry"})," object"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"registry"})," is an object containing the registered core, theme and custom fields and widgets as well as the root schema, form context, schema utils."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"fields"}),": The set of all fields used by the ",(0,t.jsx)(n.code,{children:"Form"}),". Includes fields from ",(0,t.jsx)(n.code,{children:"core"}),", theme-specific fields and any ",(0,t.jsx)(n.a,{href:"#custom-field-components",children:"custom registered fields"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"widgets"}),": The set of all widgets used by the ",(0,t.jsx)(n.code,{children:"Form"}),". Includes widgets from ",(0,t.jsx)(n.code,{children:"core"}),", theme-specific widgets and any ",(0,t.jsx)(n.a,{href:"#custom-component-registration",children:"custom registered widgets"}),", if any;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rootSchema"}),": The root schema, as passed to the ",(0,t.jsx)(n.code,{children:"Form"}),", which can contain referenced ",(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/json-schema/definitions",children:"definitions"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"formContext"}),": The ",(0,t.jsx)(n.a,{href:"/react-jsonschema-form/docs/api-reference/form-props#formcontext",children:"formContext"})," that was passed to ",(0,t.jsx)(n.code,{children:"Form"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"schemaUtils"}),": The current implementation of the ",(0,t.jsx)(n.code,{children:"SchemaUtilsType"})," (from ",(0,t.jsx)(n.code,{children:"@rjsf/utils"}),") in use by the ",(0,t.jsx)(n.code,{children:"Form"}),". Used to call any of the validation-schema-based utility functions."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The registry is passed down the component tree, so you can access it from your custom field, custom widget, custom template and ",(0,t.jsx)(n.code,{children:"SchemaField"})," components."]}),"\n",(0,t.jsx)(n.h3,{id:"custom-schemafield",children:"Custom SchemaField"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warning:"})," This is a powerful feature as you can override the whole form behavior and easily mess it up. Handle with care."]}),"\n",(0,t.jsxs)(n.p,{children:["You can provide your own implementation of the ",(0,t.jsx)(n.code,{children:"SchemaField"})," base React component for rendering any JSONSchema field type, including objects and arrays. This is useful when you want to augment a given field type with supplementary powers."]}),"\n",(0,t.jsxs)(n.p,{children:["To proceed so, pass a ",(0,t.jsx)(n.code,{children:"fields"})," object having a ",(0,t.jsx)(n.code,{children:"SchemaField"})," property to your ",(0,t.jsx)(n.code,{children:"Form"})," component; here's an example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, FieldProps, RegistryFieldsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst CustomSchemaField = function (props: FieldProps) {\n  return (\n    <div id='custom'>\n      <p>Yeah, I'm pretty dumb.</p>\n      <div>My props are: {JSON.stringify(props)}</div>\n    </div>\n  );\n};\n\nconst fields: RegistryFieldsType = {\n  SchemaField: CustomSchemaField,\n};\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nrender(<Form schema={schema} validator={validator} fields={fields} />, document.getElementById('app'));\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you're curious how this could ever be useful, have a look at the ",(0,t.jsx)(n.a,{href:"https://github.com/Kinto/formbuilder",children:"Kinto formbuilder"})," repository to see how it's used to provide editing capabilities to any form field."]}),"\n",(0,t.jsxs)(n.p,{children:["Props passed to a custom SchemaField are the same as ",(0,t.jsx)(n.a,{href:"#field-props",children:"the ones passed to a custom field"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"custom-arrayschemafield",children:"Custom ArraySchemaField"}),"\n",(0,t.jsxs)(n.p,{children:["Everything that was mentioned above for a ",(0,t.jsx)(n.code,{children:"Custom SchemaField"})," applies, but this is only used to render the Array item ",(0,t.jsx)(n.code,{children:"children"})," that are then passed to the ",(0,t.jsx)(n.code,{children:"ArrayFieldItemTemplate"}),".\nBy default, ",(0,t.jsx)(n.code,{children:"ArraySchemaField"})," is not actually implemented in the ",(0,t.jsx)(n.code,{children:"fields"})," list since ",(0,t.jsx)(n.code,{children:"ArrayField"})," falls back to ",(0,t.jsx)(n.code,{children:"SchemaField"})," if ",(0,t.jsx)(n.code,{children:"ArraySchemaField"})," is not provided.\nIf you want to customize how the individual items for an array are rendered, provide your implementation of ",(0,t.jsx)(n.code,{children:"ArraySchemaField"})," as a ",(0,t.jsx)(n.code,{children:"fields"})," override."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, UiSchema, FieldProps, RegistryFieldsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst CustomArraySchemaField = function (props: FieldProps) {\n  const { index, registry } = props;\n  const { SchemaField } = registry.fields;\n  const name = `Index ${index}`;\n  return <SchemaField {...props} name={name} />;\n};\n\nconst fields: RegistryFieldsType = {\n  ArraySchemaField: CustomArraySchemaField,\n};\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nrender(<Form schema={schema} validator={validator} fields={fields} />, document.getElementById('app'));\n"})}),"\n",(0,t.jsx)(n.h3,{id:"custom-field-by-id",children:"Custom Field by Id"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warning:"})," This is a powerful feature as you can override the whole form behavior and easily mess it up. Handle with care."]}),"\n",(0,t.jsxs)(n.p,{children:["You can provide your own implementation of the field component that applies to any schema or sub-schema based on the schema's ",(0,t.jsx)(n.code,{children:"$id"})," value. This is useful when your custom field should be conditionally applied based on the schema rather than the property name or data type."]}),"\n",(0,t.jsxs)(n.p,{children:["To provide a custom field in this way, the ",(0,t.jsx)(n.code,{children:"fields"})," prop should be an object which contains a key that matches the ",(0,t.jsx)(n.code,{children:"$id"})," value of the schema which should have a custom field; here's an example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema, FieldProps, RegistryFieldsType } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst CustomIdField = function (props: FieldProps) {\n  return (\n    <div id='custom'>\n      <p>Yeah, I'm pretty dumb.</p>\n      <div>My props are: {JSON.stringify(props)}</div>\n    </div>\n  );\n};\n\nconst fields: RegistryFieldsType = {\n  '/schemas/my-id': CustomIdField,\n};\n\nconst schema: RJSFSchema = {\n  $id: '/schemas/my-id',\n  type: 'string',\n};\n\nrender(<Form schema={schema} validator={validator} fields={fields} />, document.getElementById('app'));\n"})}),"\n",(0,t.jsx)(n.h3,{id:"wrapping-an-existing-field-to-customize-it",children:"Wrapping an existing field to customize it"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes you just need to customize the properties that are passed to an existing field."}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example of wrapping the ",(0,t.jsx)(n.code,{children:"ObjectField"})," to tweak the ",(0,t.jsx)(n.code,{children:"onChange"})," handler to look for a specific kind of bad data:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useCallback } from 'react';\nimport { FieldProps } from '@rjsf/utils';\nimport { getDefaultRegistry } from '@rjsf/core';\n\nimport checkBadData from './checkBadData';\n\nconst {\n  fields: { ObjectField },\n} = getDefaultRegistry();\n\nfunction MyObjectField(props: FieldProps) {\n  const { onChange } = props;\n  const onChangeHandler = useCallback(\n    (newFormData: T | undefined, path: (number | string)[], es?: ErrorSchema<T>, id?: string) => {\n      let data = newFormData;\n      let error = es;\n      if (checkBadData(newFormData)) {\n        // Format the `error` and fix the `data` here\n      }\n      onChange(data, path, error, id);\n    },\n    [onChange],\n  );\n  return <ObjectField {...props} onChange={onChangeHandler} />;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);